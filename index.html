<!DOCTYPE html> <html lang="en"> <head>   <meta charset="utf-8" />   <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />   <title>Flappy Fish – Free Browser Game</title>   <meta name="description" content="Flappy Fish: a fast, lightweight HTML5 canvas game. Tap/click to swim through coral gaps. Mobile-friendly, sound on/off, score & high score." />   <meta name="theme-color" content="#0ea5e9" />   <style>     :root{       --bg: #031928;          /* deep ocean */       --sea: #062d44;         /* sea layer */       --accent: #0ea5e9;      /* cyan */       --coral: #ea580c;       /* orange coral */       --bubble: #93c5fd;      /* bubble */       --text: #e6f3ff;       --shadow: rgba(0,0,0,.25);     }     * { box-sizing: border-box; }     html, body { height: 100%; }     body {       margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";       background: radial-gradient(1200px 800px at 50% -20%, #0ea5e9 0%, var(--sea) 40%, var(--bg) 80%);       color: var(--text);       display: grid; place-items: center; padding: 0; overflow: hidden;     }     .frame {       width: min(96vw, 560px);       aspect-ratio: 9/16; /* mobile portrait */       position: relative; border-radius: 24px; overflow: hidden; box-shadow: 0 20px 60px var(--shadow);       background: linear-gradient(#063045, #02131e);       border: 1px solid rgba(255,255,255,.08);     }     canvas { width: 100%; height: 100%; display: block; }     .hud { position: absolute; inset: 0; pointer-events: none; }     .topbar { position: absolute; top: 8px; left: 8px; right: 8px; display: flex; gap: 8px; align-items: center; justify-content: space-between; pointer-events: auto; }     .pill { backdrop-filter: blur(8px); background: rgba(2, 19, 30, .5); border: 1px solid rgba(255,255,255,.08); border-radius: 999px; padding: 8px 12px; display: inline-flex; align-items: center; gap: 8px; box-shadow: inset 0 1px 0 rgba(255,255,255,.06); }     .btn { cursor: pointer; user-select: none; }     .btn:active { transform: translateY(1px); }     .score { font-weight: 800; letter-spacing: .5px; }     .center { position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none; text-align: center; padding: 16px; }     .card { pointer-events: auto; max-width: 90%; backdrop-filter: blur(10px); background: rgba(2,19,30,.6); border: 1px solid rgba(255,255,255,.1); border-radius: 16px; padding: 16px; box-shadow: 0 12px 32px var(--shadow); }     h1 { font-size: 22px; margin: 0 0 8px; }     p { margin: 6px 0; opacity: .9; }     .primary { display: inline-block; margin-top: 10px; padding: 10px 14px; border-radius: 12px; background: linear-gradient(135deg, #22d3ee, #0ea5e9); color: #001018; font-weight: 800; cursor: pointer; text-decoration: none; }     .secondary { display: inline-block; margin-left: 8px; padding: 10px 14px; border-radius: 12px; background: rgba(255,255,255,.08); color: var(--text); font-weight: 700; cursor: pointer; text-decoration: none; }     .bottom { position: absolute; left: 0; right: 0; bottom: 8px; display: flex; justify-content: center; pointer-events: none; }     .ad-banner { width: calc(100% - 16px); height: 60px; max-width: 440px; border-radius: 12px; background: rgba(255,255,255,.06); border: 1px dashed rgba(255,255,255,.25); display: grid; place-items: center; color: #bcd7ff; font-size: 12px; pointer-events: auto; }     .interstitial { position: absolute; inset: 0; display: none; place-items: center; background: rgba(0,0,0,.6); backdrop-filter: blur(2px); }     .interstitial .content { width: 86%; max-width: 420px; background: #071a28; border: 1px solid rgba(255,255,255,.1); border-radius: 16px; padding: 16px; text-align: center; }     .muted { opacity: .7 }     .tiny { font-size: 11px; opacity: .8 }     /* Utility */     .row { display: inline-flex; gap: 8px; align-items: center; }   </style> </head> <body>   <div class="frame" id="frame">     <canvas id="game" width="360" height="640" aria-label="Flappy Fish Game"></canvas>     <div class="hud">       <div class="topbar">         <div class="pill">           <span>🐟 Flappy Fish</span>         </div>         <div class="row">           <div class="pill score" id="scorePill">Score: 0</div>           <div class="pill" id="soundBtn" role="button" aria-pressed="false" title="Toggle sound">🔊</div>           <div class="pill btn" id="pauseBtn" role="button" aria-pressed="false" title="Pause/Resume">⏸️</div>         </div>       </div>       <div class="center" id="startOverlay">         <div class="card">           <h1>Tap to Swim</h1>           <p>Navigate through coral gaps. Touch, click, or press <strong>Space</strong>.</p>           <p class="tiny">Best: <span id="bestStart">0</span></p>           <a class="primary" id="playBtn">Play</a>           <a class="secondary" id="howBtn">How to Play</a>         </div>       </div>       <div class="center" id="howOverlay" style="display:none">         <div class="card">           <h1>How to Play</h1>           <p>• Tap/click/Space to swim up. Avoid coral.</p>           <p>• Pass a gap to score +1. Beat your best score!</p>           <p>• Works on mobile and desktop.</p>           <a class="primary" id="closeHow">Got it</a>         </div>       </div>       <div class="center" id="gameOverOverlay" style="display:none">         <div class="card">           <h1>Game Over</h1>           <p>Score: <strong id="finalScore">0</strong> &nbsp;•&nbsp; Best: <strong id="bestScore">0</strong></p>           <a class="primary" id="retryBtn">Play Again</a>           <a class="secondary" id="shareBtn">Share</a>         </div>       </div>       <div class="bottom">         <!-- 🧾 Ad Banner Placeholder: Replace this div with your AdSense banner code after approval. -->         <div class="ad-banner" id="adBanner">Ad banner placeholder (insert AdSense code here)</div>       </div>       <!-- Interstitial Placeholder (triggered every few fails) -->       <div class="interstitial" id="interstitial">         <div class="content">           <p>Interstitial Ad (placeholder)</p>           <p class="tiny">Replace with your AdSense/Ad network fullscreen unit.</p>           <a class="primary" id="closeInterstitial">Continue</a>         </div>       </div>     </div>   </div>   <script>     // ====== Utility: DPR-friendly canvas sizing ======  
  const canvas = document.getElementById('game');     const ctx = canvas.getContext('2d');     function fitCanvas() {       const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));       const cssW = canvas.clientWidth | 0;       const cssH = canvas.clientHeight | 0;       if (!cssW || !cssH) return;       canvas.width = Math.round(cssW * dpr);       canvas.height = Math.round(cssH * dpr);       ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw using CSS pixels    
                                                                                                                    }     new ResizeObserver(fitCanvas).observe(canvas);     window.addEventListener('orientationchange', () => setTimeout(fitCanvas, 120));     // ====== Simple Audio (WebAudio, no external libs) ======     
  const AudioCtx = window.AudioContext || window.webkitAudioContext;     let audioCtx = null; // created lazily on first user gesture    
  let soundEnabled = true;     const soundBtn = document.getElementById('soundBtn');     function initAudio() {       if (!audioCtx) audioCtx = new AudioCtx();     }     function playBeep({freq=600, time=0.07, type='sine', gain=0.08}={}) {       if (!soundEnabled) return;       try {         initAudio();         const t0 = audioCtx.currentTime;         const osc = audioCtx.createOscillator();         const g = audioCtx.createGain();         osc.type = type; osc.frequency.setValueAtTime(freq, t0);         g.gain.setValueAtTime(gain, t0);         g.gain.exponentialRampToValueAtTime(0.0001, t0 + time);         osc.connect(g).connect(audioCtx.destination);         osc.start(t0); osc.stop(t0 + time);       } catch {}     }
  function playSwim(){ playBeep({freq: 520, time: .06, type:'triangle', gain:.06}); }     function playScore(){ playBeep({freq: 800, time: .09, type:'square', gain:.06}); }     function playHit(){ playBeep({freq: 120, time: .16, type:'sawtooth', gain:.08}); }     soundBtn.addEventListener('click', () => {       soundEnabled = !soundEnabled; soundBtn.textContent = soundEnabled ? '🔊' : '🔇';       soundBtn.setAttribute('aria-pressed', String(!soundEnabled));       if (soundEnabled) initAudio();     });     // ====== Game State ======
  const startOverlay = document.getElementById('startOverlay');     const howOverlay = document.getElementById('howOverlay');     const closeHow = document.getElementById('closeHow');     const playBtn = document.getElementById('playBtn');     const howBtn = document.getElementById('howBtn');     const pauseBtn = document.getElementById('pauseBtn');     const scorePill = document.getElementById('scorePill');     const gameOverOverlay = document.getElementById('gameOverOverlay');     const retryBtn = document.getElementById('retryBtn');     const shareBtn = document.getElementById('shareBtn');     const finalScoreEl = document.getElementById('finalScore');     const bestScoreEl = document.getElementById('bestScore');     const bestStartEl = document.getElementById('bestStart');     const interstitial = document.getElementById('interstitial');     const closeInterstitial = document.getElementById('closeInterstitial');     let running = false, paused = false, gameOver = false;     let score = 0; let best = Number(localStorage.getItem('ff_best')||0);     bestStartEl.textContent = best;     const G = 1250;          // gravity px/s^2  
  const FLAP = -450;       // impulse velocity  
  const MAX_VY = 720;      // clamp fall speed     // fish properties (in CSS pixels)
  const fish = { x: 90, y: 280, vy: 0, r: 14, rot: 0 };     // Obstacles  
  const pipes = []; // each: {x, gapY} 
  const pipeGap = 200;           // vertical gap size  
  const pipeW = 50;              // pipe width  
  const pipeSpacing = 220;       // distance between pipes  
  const pipeSpeed = 150;         // px/s leftward   
  // Spawn management  
  let lastSpawnX = 0;     function resetGame() {       running = true; paused = false; gameOver = false; score = 0;       fish.x = 90; fish.y = canvas.clientHeight * 0.45; fish.vy = 0; fish.rot = 0;       pipes.length = 0; lastSpawnX = 0;       scorePill.textContent = `Score: ${score}`;       hide(gameOverOverlay); hide(startOverlay); hide(howOverlay);       fitCanvas();     }     function show(el){ el.style.display = '' }     function hide(el){ el.style.display = 'none' }     playBtn.addEventListener('click', () => { initAudio(); resetGame(); });     howBtn.addEventListener('click', () => { show(howOverlay); });     closeHow.addEventListener('click', () => { hide(howOverlay); });     retryBtn.addEventListener('click', () => { maybeShowInterstitial(); resetGame(); });     pauseBtn.addEventListener('click', () => { if (!running) return; paused = !paused; pauseBtn.textContent = paused ? '▶️' : '⏸️'; });     shareBtn.addEventListener('click', async () => {       const text = `I scored ${score} in Flappy Fish! Can you beat me?`;       try { if (navigator.share) { await navigator.share({ text, url: location.href, title: 'Flappy Fish' }); return; } } catch {}       navigator.clipboard?.writeText(`${text} ${location.href}`);       alert('Share text copied to clipboard!');     });     // Interstitial: every 3rd fail
  let failCount = Number(localStorage.getItem('ff_fails')||0);     function maybeShowInterstitial(){       failCount++; localStorage.setItem('ff_fails', String(failCount));       if (failCount % 3 === 0) {         interstitial.style.display = 'grid';       }     }     closeInterstitial.addEventListener('click', () => interstitial.style.display = 'none');    
  // Controls   
  function flap(){ if (!running || paused || gameOver) return; fish.vy = FLAP; playSwim(); }     window.addEventListener('keydown', e => {       if (e.code === 'Space') { e.preventDefault(); if (!running) resetGame(); else flap(); }       if (e.code === 'KeyP') { paused = !paused; pauseBtn.textContent = paused ? '▶️' : '⏸️'; }     }, {passive:false});     canvas.addEventListener('pointerdown', (e)=>{ e.preventDefault(); if (!running) resetGame(); else flap(); }, {passive:false});     document.addEventListener('visibilitychange', () => { if (document.hidden) paused = true; });     // ====== Game Loop ======  
  let last = performance.now();     function loop(now){       requestAnimationFrame(loop);       const dt = Math.min(0.033, (now - last) / 1000); last = now;       if (!running || paused) { draw(); return; }       update(dt); draw();     }     function update(dt){       // Spawn pipes as world scrolls
    const needSpawn = (pipes.length === 0) || (canvas.clientWidth - (pipes[pipes.length-1]?.x ?? 0) >= pipeSpacing);       if (needSpawn){         const margin = 80; // keep gap fully on screen  
                                                                                                                                          const h = canvas.clientHeight;         const gapY = Math.random() * (h - margin*2 - pipeGap) + margin + pipeGap/2;         pipes.push({ x: canvas.clientWidth + pipeW, gapY, scored: false });       }       // Move pipes  
    for (const p of pipes) p.x -= pipeSpeed * dt;       // Drop off-screen pipes  
    while (pipes.length && pipes[0].x + pipeW < 0) pipes.shift();       // Physics
    fish.vy = Math.min(MAX_VY, fish.vy + G * dt);       fish.y += fish.vy * dt;       fish.rot = Math.atan2(fish.vy, 300);       // Collisions & scoring 
    const top = 0, bottom = canvas.clientHeight;       if (fish.y - fish.r < top || fish.y + fish.r > bottom){ endGame(); return; }       for (const p of pipes){         const inX = fish.x + fish.r > p.x && fish.x - fish.r < p.x + pipeW;         const gapTop = p.gapY - pipeGap/2; const gapBot = p.gapY + pipeGap/2;         if (inX){           if (fish.y - fish.r < gapTop || fish.y + fish.r > gapBot){ endGame(); return; }         }         if (!p.scored && p.x + pipeW < fish.x - fish.r){ p.scored = true; score++; scorePill.textContent = `Score: ${score}`; playScore(); }       }     }     function endGame(){       running = false; gameOver = true; playHit();       best = Math.max(best, score); localStorage.setItem('ff_best', String(best));       finalScoreEl.textContent = score; bestScoreEl.textContent = best;       show(gameOverOverlay);     }     function draw(){       const w = canvas.clientWidth, h = canvas.clientHeight;       // Clear water background with gradient b                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ctx.clearRect(0,0,w,h);       const grad = ctx.createLinearGradient(0,0,0,h);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          grad.addColorStop(0, '#07324b');       grad.addColorStop(.6, '#062b40');       grad.addColorStop(1, '#041c2a');       ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);       // Bubbles (lightweight procedural)  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          const t = performance.now() * 0.001;       for (let i=0;i<16;i++){         const bx = (i*97 % w);         const by = (h - ((t*30 + i*30) % (h+40)));         ctx.globalAlpha = 0.10 + (i%5)*0.03;         ctx.beginPath(); ctx.arc(bx, by, 3 + (i%3), 0, Math.PI*2); ctx.fillStyle = '#93c5fd'; ctx.fill();       }       ctx.globalAlpha = 1;       // Draw pipes as coral columns  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          for (const p of pipes){         ctx.fillStyle = '#ea580c';         const gapTop = p.gapY - pipeGap/2; const gapBot = p.gapY + pipeGap/2;         // top coral         
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 roundRect(ctx, p.x, -2, pipeW, gapTop+2, 10);         // bottom coral 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 roundRect(ctx, p.x, gapBot, pipeW, h-gapBot+2, 10);         // subtle texture lines         
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ctx.strokeStyle = 'rgba(0,0,0,.15)'; ctx.lineWidth = 2;         ctx.beginPath(); ctx.moveTo(p.x+8, 0); ctx.lineTo(p.x+8, h); ctx.stroke();       }       // Draw fish       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ctx.save();       ctx.translate(fish.x, fish.y); ctx.rotate(fish.rot);       // body       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ctx.fillStyle = '#22d3ee';       ellipse(ctx, 0, 0, 22, 14);       // tail       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ctx.fillStyle = '#0ea5e9';       ctx.beginPath(); ctx.moveTo(-18, -6); ctx.lineTo(-32, 0); ctx.lineTo(-18, 6); ctx.closePath(); ctx.fill();       // eye      
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(8, -3, 3.5, 0, Math.PI*2); ctx.fill();       ctx.fillStyle = '#001018'; ctx.beginPath(); ctx.arc(9, -3, 1.5, 0, Math.PI*2); ctx.fill();       // bubble from mouth    
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.arc(20 + Math.sin(t*6)*2, -6 + Math.cos(t*8), 2.2, 0, Math.PI*2); ctx.fillStyle = '#bde0ff'; ctx.fill(); ctx.globalAlpha = 1;       ctx.restore();       // Ground gradient at bottom      
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          const seabed = ctx.createLinearGradient(0, h-100, 0, h);       seabed.addColorStop(0, 'rgba(234,88,12,.08)');       seabed.addColorStop(1, 'rgba(2,19,30,1)');       ctx.fillStyle = seabed; ctx.fillRect(0, h-100, w, 100);     }     function roundRect(ctx, x,y,w,h,r){       const rr = Math.min(r, Math.abs(w)/2, Math.abs(h)/2);       ctx.beginPath();       ctx.moveTo(x+rr, y);       ctx.arcTo(x+w, y, x+w, y+h, rr);       ctx.arcTo(x+w, y+h, x, y+h, rr);       ctx.arcTo(x, y+h, x, y, rr);       ctx.arcTo(x, y, x+w, y, rr);       ctx.closePath(); ctx.fill();     }     function ellipse(ctx, x,y, rx, ry){ ctx.beginPath(); ctx.ellipse(x,y,rx,ry,0,0,Math.PI*2); ctx.fill(); }     // Boot     
  fitCanvas(); requestAnimationFrame(loop);     // Show start overlay initially
  show(startOverlay);     // ===== Monetization Integration Notes =====     // 1) Replace the banner placeholder div (#adBanner) with the official AdSense code after your site is approved.     //    Example (DO NOT paste your pub id here in public repos):     //    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXX" crossorigin="anonymous"></script>     //    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-XXXX" data-ad-slot="YYYY" data-ad-format="auto" data-full-width-responsive="true"></ins>     //    <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>     // 2) Replace the interstitial placeholder (#interstitial) with your network's fullscreen interstitial implementation.     // 3) Consider an "Remove Ads" button that opens a Stripe/Gumroad checkout and stores a flag in localStorage to hide ads.   </script> </body> </html>  
